# AI-Developed OIDC Auth Demo (React + Spring Boot)

[![CI](https://github.com/rhofkens/oidc-auth-react-springboot-demo/actions/workflows/ci.yml/badge.svg)](https://github.com/rhofkens/oidc-auth-react-springboot-demo/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
![React](https://img.shields.io/badge/react-%2320232a.svg?style=flat&logo=react&logoColor=%2361DAFB)
![Spring](https://img.shields.io/badge/spring-%236DB33F.svg?style=flat&logo=spring&logoColor=white)
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=flat&logo=openjdk&logoColor=white)
![TypeScript](https://img.shields.io/badge/typescript-%233178C6.svg?style=flat&logo=typescript&logoColor=white)

## What This Project Does

This project is a minimal web application designed to visually demonstrate the difference between guest and authenticated user access to backend services using OpenID Connect (OIDC). It serves as a practical example and base implementation for integrating standard OIDC authentication flows in a modern web stack.

**Key Features:**

*   **Guest vs. Authenticated Views:** Clearly shows different UI states and data access based on whether the user is logged in or browsing as a guest.
*   **OIDC Integration:** Implements standard OIDC Authorization Code flow with PKCE for secure authentication against an OIDC provider (configured for Zitadel).
*   **Frontend-Backend Interaction:** Features a React frontend that interacts with a Spring Boot backend API.
*   **Protected Resources:** Includes a public API endpoint accessible to everyone and a private endpoint requiring authentication.
*   **Session Management:** Demonstrates handling of authentication tokens and session persistence across browser refreshes.

**Technology Stack:**

*   **Backend:** Java 21, Spring Boot 3.4.4, Spring Security 6 (Resource Server), Maven
*   **Frontend:** React 19, TypeScript, Vite, Tailwind CSS, shadcn/ui, oidc-client-ts
*   **Authentication:** OIDC (Authorization Code + PKCE), JWT validation

## Why and How This Project Was Developed

This project was developed with a specific goal: **to create an enterprise-grade, reusable authentication package using a fully automated AI-native coding workflow.**

*   **Goal:** The primary objective was to build a robust foundation for OIDC authentication that adheres to modern best practices, achieves high test coverage (â‰¥80%), includes comprehensive documentation, and can be readily adapted for real-world enterprise projects. A secondary goal was to establish and refine a clear, repeatable workflow for AI-driven software development using VScode and Roo Code.
*   **Process:**
    *   The initial Product Requirements Document (PRD), Architecture Guidelines, Coding Guidelines, and High-Level Plan were drafted using an AI assistant (o3).
    *   From that point, the entire implementation followed a strictly automated flow defined in `.clinerules` and `.roomodes`, executed by Roo Code.
    *   While highly automated, the workflow incorporated deliberate human review checkpoints at key stages (e.g., after planning subtasks for each implementation step). This ensured alignment and allowed for course correction where needed, keeping the human developer in control.
*   **AI Models Used:** The core coding tasks were performed by Large Language Models, specifically Anthropic's Sonnet 3.7 and Google's Gemini Pro (preview-03-25). While both were effective, the code generated by Gemini Pro was often preferred, though it came at a higher operational cost.
*   **Outcome:** The development process achieved a high degree of automation (estimated at 97%+), successfully producing the target application according to the predefined specifications and quality gates. It validated the AI-native workflow as a viable approach for building quality software components efficiently.

## Prerequisites

- JDK 21
- Node.js 20
- pnpm (latest version)

## Project Structure

This is a monorepo containing:

- `backend/`: Spring Boot 3.4.4 application (Java 21)
- `frontend/`: React 19 application with TypeScript, Vite, and Tailwind CSS
- `docs/`: Project documentation, including PRD, architecture, guidelines, and implementation plans.

## Getting Started

### Backend

```bash
cd backend
# Ensure .env file is configured (see Environment Variables section)
./mvnw spring-boot:run
```

The backend will start on http://localhost:8080.

### Frontend

```bash
cd frontend
pnpm install
# Ensure .env file is configured (see Environment Variables section)
pnpm dev
```

The frontend development server will start on http://localhost:5173.

> **Note:** The frontend dev server includes a proxy configuration that forwards all `/api` requests to the backend server running on port 8080. Make sure the backend server is running when developing the frontend.

### Guest Mode Caching

The frontend implements a caching mechanism for the public health check endpoint in guest mode.

- The response from `/api/v1/public/health` is stored in the browser's `sessionStorage`.
- If the backend is unavailable when the page loads, the UI will display the last known status from the cache ("stale data") instead of showing an error immediately.
- During development, if you need to clear this cache to fetch fresh data, you can do so via your browser's developer tools (usually under the "Application" or "Storage" tab, look for `sessionStorage`).

## Environment Variables

This project uses environment variables for configuration, particularly for OIDC authentication details. Template files are provided:

- `.env.example` (at the project root, for backend configuration)
- `frontend/.env.example` (in the frontend directory, for frontend configuration)

These files list the required variables but contain placeholder values.

**To configure your local environment:**

1.  **Copy the templates:**
    ```bash
    cp .env.example .env
    cp frontend/.env.example frontend/.env
    ```
2.  **Edit the `.env` files:** Open the newly created `.env` files (in the root directory and the `frontend/` directory) and replace the placeholder values with your actual Zitadel application details (Issuer URI, Client IDs, Client Secret). Refer to `docs/auth-config.md` for details on each variable.

**Important:** The `.env` files contain sensitive information and are listed in `.gitignore`. **Never commit `.env` files to the Git repository.**


## Running with OIDC

The frontend application uses the OpenID Connect (OIDC) Authorization Code flow with Proof Key for Code Exchange (PKCE) for user authentication. This is implemented using the `oidc-client-ts` library.

To run the application with OIDC authentication enabled, you need to configure the following environment variables in the `frontend/.env` file (refer to `frontend/.env.example` for the format):

- `VITE_ZITADEL_ISSUER_URI`: The URI of your Zitadel instance.
- `VITE_ZITADEL_CLIENT_ID`: The Client ID of your Zitadel application.
- `VITE_ZITADEL_SCOPES`: The OIDC scopes required by the application (e.g., `openid profile email private.read`).

Additionally, ensure your Zitadel client application is configured with the following settings:

- **Application Type:** `User Agent`
- **Authentication Method:** `None` (PKCE is used)
- **Redirect URIs:** `http://localhost:5173/auth/callback`
- **Post Logout URIs:** `http://localhost:5173/`

## Testing

### Backend

Run the tests:

```bash
cd backend
./mvnw test
```

Run tests with coverage report:

```bash
cd backend
./mvnw verify
```

This will run the tests and generate a coverage report in `backend/target/site/jacoco/`. You can open `backend/target/site/jacoco/index.html` in a browser to view the detailed coverage report.

To check if coverage meets the required threshold (80%):

```bash
cd backend
./mvnw verify -Pcoverage-check
```

### Frontend

Run the tests:

```bash
cd frontend
pnpm test
```

Run tests in watch mode during development:

```bash
cd frontend
pnpm test:watch
```

Run tests with coverage report:

```bash
cd frontend
pnpm test:coverage
```

This will run the tests and generate a coverage report in `frontend/coverage/`. You can open `frontend/coverage/index.html` in a browser to view the detailed coverage report.

The coverage thresholds are configured to require at least 80% coverage for statements, branches, functions, and lines.

## Development

- The backend uses Spotless for code formatting. Run `./mvnw spotless:apply` to format the code.
- The frontend uses ESLint and Prettier for linting and formatting. Run `pnpm lint` and `pnpm format` to lint and format the code.
- Pre-commit hooks are set up using `lint-staged` and `husky` to ensure code quality before commits.

## API Endpoints

### Health Check (Public)

```bash
curl -X GET http://localhost:8080/api/v1/public/health
```

Example response:
```json
{
  "message": "Service up"
}

### Private Info (Requires Authentication)

```bash
# Replace <your_jwt_token> with a valid access token obtained via OIDC login
curl -H "Authorization: Bearer <your_jwt_token>" http://localhost:8080/api/v1/private/info
```

Example response (if authorized):
```json
{
  "message": "Hello John Doe (from UserInfo)",
  "email": "user@example.com"
}
```
*Note: The actual message will contain the first and last name retrieved from the OIDC provider's UserInfo endpoint.*

You can obtain a test token by logging into the frontend application, which stores the access token. You can inspect network requests or use browser developer tools to find the token.
